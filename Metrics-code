#Lets just give this a go on a simple network:
library(sna)
library(igraph)
library(ergm)
library(intergraph) #Converts between sna and igraph objects.

data('sampson')
gr = samplike
gr$gal$directed = F

size = 100
gest = simulate(network(size, directed = F)~edges, nsim = 1, 
             coef = c(-0.4355))

num.iters = 1000
F.pos.vec = c(0.01, 0.05, 0.1, 0.15, 0.2)
F.neg.vec = c(0.01, 0.05, 0.1, 0.15, 0.2)

#start of loop
run.metrics = function(vector.of.false.positive.rates, vector.of.false.negative.rates, number.iterations, graph, data.set.name){
  record = list(density.rec = list(), 
                distance.rec = list(), 
                degree.dist.rec = list(), 
                edge.con.rec = list(), 
                degree.rec = list(),
                closeness.rec = list(),
                betweenness.rec = list(),
                bonacich.rec = list(),
                eigen.cent.rec = list(),
                gil.sch.rec = list(),
                info.cent.rec = list(),
                load.rec = list(),
                klein.auth.rec = list()
  )
  base_graph = gest
  for (F.pos.rate in F.pos.vec) {
    for (F.neg.rate in F.neg.vec) {
      gest = base_graph
      for (i in 1:num.iters){
        #Run metrics on the graph and record them:
        
        #Transformation function to change from sna to igraph:
        gest = intergraph::asIgraph(gest)
        
        ##################### Igraph metrics:
        
        #Density:
        record$density.rec[i] = igraph::edge_density(gest)
        #Distance:
        record$distance.rec[[i]] = igraph::distances(gest)
        #Degree distribution:
        record$degree.dist.rec[[i]] = igraph::degree.distribution(gest, mode = "total")
        #Kleinberg's authority centrality score
        record$klein.auth.rec[[i]] = igraph::authority.score(gest)
        #Edge connectivity
        record$edge.con.rec[[i]] = igraph::edge_connectivity(gest)
        
        ####################### SNA metrics:
        
        #Transformation function to change from igraph to sna:
        gest = intergraph::asNetwork(gest)
        #Degree centrality:
        record$degree.rec[[i]] = sna::degree(gest, gmode = "graph")
        #Closeness Centrality:
        record$closeness.rec[[i]] = sna::closeness(gest, gmode = "graph")
        #Betweenness Centrality:
        record$betweenness.rec[[i]] = sna::betweenness(gest, gmode = "graph")
        #Eigenvector centrality:
        record$eigen.cent.rec[[i]] = sna::evcent(gest, gmode = "graph")
        #Gil-Schmidt Power index:
        record$gil.sch.rec[[i]] = sna::gilschmidt(gest, gmode = "graph")
        #Information Centrality:
        record$info.cent.rec[[i]] = sna::infocent(gest, gmode = "graph")
        #Load Centrality:
        record$load.rec[[i]] = sna::loadcent(gest, gmode = "graph")
        
        #Method of applying false positives or negatives: (if a function, should be defined outside the loop.) 
        #(depending on if igraph or sna has a better method determines where this goes)
        #Should be able to state at start if looking for false pos or negs.
        #false.pos.rate is the rate at which false positive occur. Meaning arcs which go from 0 to 1
        #false.neg.rate is the rate at which false positive occur. Meaning arcs which go from 1 to 0
        #Sample already takes the floor of the number of values we want so no concern for non-integer values.
        
        #Bonacinch Power Centrality:
        #Bonacinch power formula requires the matrix to be non-singular.
        gest = as.matrix.network.adjacency(gest)
        # if (det(gest) < 1e-6 || det(gest) > -1e-6){
        #   gest = as.network.matrix(gest)
        #   record$bonacich.rec[[i]] = sna::bonpow(gest, gmode = "graph", tol = 1e-07)
        #   gest = as.matrix.network.adjacency(gest)
        # }
        
        F.pos.which = which(gest == 0)
        F.neg.which = which(gest == 1)
        
        F.pos.which.length = length(F.pos.which)
        F.neg.which.length = length(F.neg.which)
        
        F.pos.arcs = sample(F.pos.which, ceiling(F.pos.rate*F.pos.which.length))
        F.neg.arcs = sample(F.neg.which, ceiling(F.neg.rate*F.neg.which.length))
        
        gest[F.pos.arcs] = 1
        gest[F.neg.arcs] = 0
        
        
        gest = as.network.matrix(gest)
        
        #Density will never reach 0 or 1 as we are only changing n% of the arcs that are 0 or 1.
        #Taking ceiling as sample by default takes floor which means that when we get values 0<x<1 we try sample 0
      }
      save(record, file = paste(data.set.name, F.pos.rate, F.neg.rate, sep = "_"))
    }
  }
}

a = proc.time()
cool = run.metrics(F.pos.vec, F.neg.vec, num.iters, gest, "sampson")
b = proc.time()


data.set.name = "sampson"
F.pos.rate = 0.01
F.neg.rate = 0.02
cool = load(file = paste(data.set.name, F.pos.rate, F.neg.rate, sep = "_"))
aa = cool$density.rec
plot(1:length(unlist(aa)), unlist(aa))
